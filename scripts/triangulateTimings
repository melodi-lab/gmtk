#!/usr/nikola/bin/perl -w 
# $Header$


use strict;
use Getopt::Long;
use File::Basename;
use File::Copy;
use IPC::Open2; 
use Symbol; 

my $valid_options; 
my $str_file; 
my $timing_script;
my $export_line;
my $input_triangulation;
my $timing_length; 
my $best_partitions; 
my @run_once; 
my @run_many; 
my @iterations; 
my $str_basename;
my $tmp_tri_file;
my $output;
my $crrnt_weight;
my $crrnt_partitions;
my $method;
my $working_dir;
my $number;

my $gmtk_triangulate;
my $pmae;
my $pmake;

##############################################################################
# GMTK tool names
# -Do not add paths to these definitons, alter your path instead
##############################################################################
$gmtk_triangulate = 'gmtkTriangulate'; 
$pmae             = 'pmae'; 
$pmake            = 'pmake'; 

#$timing_length = 7; 
$timing_length = 20; 

@run_once = ( 'completed', 'heuristics' );
@run_many = ( 'R', 'W', 'MCS', 'F', 'pre-edge-lo-R', 'pre-edge-lo-W', 'pre-edge-lo-MCS', 'pre-edge-lo-F', 'pre-edge-all-R', 'pre-edge-all-W', 'pre-edge-all-MCS', 'pre-edge-all-F', 'pre-edge-random-R', 'pre-edge-random-W', 'pre-edge-random-MCS', 'pre-edge-random-F' );
@iterations = ( 100, 10, 1 ); 

##############################################################################
# Get command line parameters 
##############################################################################
$valid_options = &GetOptions( 
  "strFile:s"               => \$str_file, 
  "exportLine:s"            => \$export_line,
  "inputTriangulatedFile:s" => \$input_triangulation, 
  "timingScript:s"          => \$timing_script
 );

##########################################################################
# Process command line parameters
##########################################################################

if (!defined $str_file)
{
  print "***ERROR:  Must supply a structure file name\n";
  $valid_options = 0;
}
else 
{
  (-e $str_file) or die "***ERROR:  '$str_file' does not exist\n"; 
}

if (!defined $export_line) 
{
  print "***ERROR:  Must supply a pmake export line\n";
  $valid_options = 0;
}

if (!defined $timing_script) 
{ 
  print "***ERROR:  Must supply a script which runs gmtkTime\n";
  $valid_options = 0;
}

if (!$valid_options) 
{
  print "Must give:\n";
  print "  1) Structure file which already has a triangulation\n"; 
  print "  2) An export line specifying a particular speed of processor for inference\n";
  print "  3) Scripts which runs gmtkTime (-inputTriangulatedFile, -strFile, and\n";
  print "     -seconds are passed in as parameters)\n"; 
  print "      -strFile                Structure file name\n";
  print "      -exportLine             pmake export line\n";
  print "      -timingScript           Script running gmtkTime\n";
  print "      -inputTriangulatedFile  Starting triangulation\n";
  die "\n";
}

if (!defined $input_triangulation)
{
  $input_triangulation = "$str_file.trifile";
}
else {
  (-e $input_triangulation) or die "***ERROR:  '$input_triangulation' does not exist\n"; 
}

$str_basename = basename($str_file); 
#$working_dir = `pwd`;
#$working_dir = '/homes/bartels/proj/crrnt_gmtk/gmtk_dev/scripts';
$working_dir = '/homes/bartels/proj/switchboard/train_1';

chomp($working_dir);

$tmp_tri_file = "$working_dir/$str_basename.tmp.trifile";

#############################################################################
# Open a copy of gmtkTime in multiTest mode 
#############################################################################
my @output;
my $timing_script_input;
my $timing_script_output;

$timing_script_input  = gensym;
$timing_script_output = gensym;

open2( $timing_script_output, $timing_script_input, "pexport -attr \'$export_line\' $timing_script -strFile $str_file -seconds $timing_length -multiTest T 2>&1 ");

#open2( $timing_script_output, $timing_script_input, "$timing_script -strFile $str_file -seconds $timing_length -multiTest T 2>&1");

$output = <$timing_script_output>;
print STDERR "$output";

#############################################################################
# Time the methods that only need to be run once  
#############################################################################
print "Triangulating $str_file\n"; 

$best_partitions = 0; 
$crrnt_partitions = run_timing( $input_triangulation );
print "Initial:  $input_triangulation  Partitions: $crrnt_partitions";
check_best( $crrnt_partitions );

foreach $method (@run_once)
{
  $crrnt_weight = run_triangulation( $method );
  $crrnt_partitions = run_timing( $tmp_tri_file );
  printf "Method: %-20s  Weight: %8f  Partitions: %6d", $method, $crrnt_weight, 
    $crrnt_partitions;
  check_best($crrnt_partitions);
}

#############################################################################
# Repeat the other methods indefinitely 
#############################################################################

while (1)
{
  foreach $number (@iterations)
  {
    foreach $method (@run_many)
    {
      $crrnt_weight = run_triangulation( "$number-$method" );
      $crrnt_partitions = run_timing( $tmp_tri_file );
      printf "Method: %-20s  Weight: %8f  Partitions: %6d", "$number-$method", 
        $crrnt_weight, $crrnt_partitions;
      check_best($crrnt_partitions);
    }
  }
}

unlink $tmp_tri_file;


#############################################################################
# run_triangulation( method );
#
#############################################################################
sub run_triangulation
{
  my $method;
  my $output;
  my $jt_weight;

  $method   = pop;

  $output = `echo \'$gmtk_triangulate -strFile $str_file -rePartition F -reTriangulate T -findBestBoundary F -inputTriangulatedFile $input_triangulation -findBestBoundary F -seed T -triangulationHeuristic $method -noReTriP T -noReTriC F -noReTriE T -outputTriangulatedFile $tmp_tri_file -printResults T -numBackupFiles 0 1>&2\' | rexport -attr \'$export_line\' -f`;

  print STDERR "$output";
  ($jt_weight) = $output =~ /Chunk max clique weight = [0-9.]+, total Cx1 weight = [0-9.]+, per-chunk total C weight = [0-9.]+, jt_weight = ([0-9.]+)/; 

  if (!defined $jt_weight) {
    $jt_weight = 99e9;
  }

  return($jt_weight); 
}


#############################################################################
# run_timing 
#
#############################################################################
sub run_timing 
{
  my $tri_file;
  my $output;
  my $partitions;

  $tri_file = pop;

  print $timing_script_input "$tri_file\n";

  ###########################################################################
  # Read in pre timing output:
  #   exported to ....        # not needed if not exporting  
  #   --------
  #   0: Operating on trifile ''
  #   0: Running program for approximately 7 seconds
  ###########################################################################
  $output = <$timing_script_output>;
  print STDERR "$output";
  $output = <$timing_script_output>;
  print STDERR "$output";
  $output = <$timing_script_output>;
  print STDERR "$output";

  ###########################################################################
  # Read in timing results:
  #   User: 6.980000, System: 0.030000, CPU 7.010000
  #   0: Inference stats: 6.98...
  ###########################################################################
  $output = <$timing_script_output>;
  print STDERR "$output";
  $output = <$timing_script_output>;
  print STDERR "$output";

  ($partitions) = $output =~ /residual partitions, ([0-9]+) total partitions,/;

  (defined $partitions) or die "Can't find # of partitions in output:'@output'";

  return($partitions);
}


#############################################################################
# check_best 
#
#############################################################################
sub check_best 
{
  my $nmbr_partitions;

  $nmbr_partitions = pop;

  #print "NP:$nmbr_partitions \n";
  #print "BP:$best_partitions \n";


  if ($nmbr_partitions > $best_partitions)
  {
    print " ==> NEW BEST!!!\n";
    $best_partitions = $nmbr_partitions;
    copy( $tmp_tri_file, "$str_basename.best.trifile" );
  }
  else 
  {
    print "\n";
  }

}

#############################################################################
# get_seconds(timestring)
#
# The input is a time string specifying:  seconds, minutes, hours, days, 
#    weeks.  Examples: 
#    '3 seconds 4 minutes 1 hour'  
#    '4min 1 hour 2 days'  
#    '1w3s1h'  
#
# Output is the integer number of seconds represented by the string.
#############################################################################
sub get_seconds 
{
  my $time_string;
  my @strings;
  my $total;
  my $string;
  my $numbers;
  my $letters;
  my $scnds;
  
  $time_string = pop;

  (@strings) = split /(\d+\s*\w+)/, $time_string;

  $total = 0;

  foreach $string (@strings)
  {
    ($numbers, $letters) = $string =~ /(\d+)\s*(\w+)/;

    if ((defined $letters) && (defined $numbers) &&  
        ('seconds' =~ /$letters/)) {
      $total = $total + $numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('minutes' =~ /$letters/)) {
      $total = $total + 60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('hours' =~ /$letters/)) {
      $total = $total + 60*60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('days' =~ /$letters/)) {
      $total = $total + 24*60*60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('weeks' =~ /$letters/)) {
      $total = $total + 7*24*60*60*$numbers;
    }
  }

  return $total;
}


