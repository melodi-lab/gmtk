#!/usr/nikola/bin/perl -w
# $Header$

use strict;
use File::Basename;
use File::Copy;
use File::Temp qw/ tempfile tempdir /;
use Getopt::Long;
use IO::Handle; 
use IPC::Open2; 
use Symbol; 
use threads; 
use Thread::Semaphore;
use Thread::Queue;

##############################################################################
# Executable names 
##############################################################################
my $gmtk_triangulate = 'gmtkTriangulate'; 

##############################################################################
# Default amount to time each triangulation 
##############################################################################
my $timing_length = 10; 

my $initial_vpap = 'COI';
my $initial_vcap = 'COI';

##############################################################################
# State variables for basic methods 
##############################################################################
my $basic_once_index    : shared = 0;
my $advanced_once_index : shared = 0;

my @run_once = ( 'completed', 'elimination-heuristics', 
  'non-elimination-heuristics' );

my @basic_iterations : shared = ( '100-', '10-', '1-' ); 
my @basic_prefix     : shared = ( '', 'pre-edge-lo-', 'pre-edge-all-', 
  'pre-edge-random-');
my @basic_suffix     : shared = ( '-1', '-2', '-3' );

#my @basic_method     : shared = ( 'MCS', 'N', 'W' );
#my $basic_suffix_threshold : shared = 1;

my @basic_method : shared = ( 'MCS', 'R', 'T', 'X', 'S', 'F', 'W', 'P', 'N' );
my $basic_suffix_threshold : shared = 1;

my $basic_iteration_index : shared = 0;
my $basic_prefix_index    : shared = 0;
my $basic_method_index    : shared = 0;
my $basic_suffix_index    : shared = 0;
my $basic_iterations_done : shared = 0;

my $boundary_searches_done : shared = 0;

##############################################################################
# State variables for advanced methods 
##############################################################################
my @advanced_UB_types   : shared = ( 'F', 'T' );
my @advanced_iterations : shared = ( '100-', '10-', '1-' ); 
my @advanced_prefix     : shared = ( '', 'pre-edge-lo-', 'pre-edge-all-', 
  'pre-edge-random-');
my @advanced_method     : shared = ( 'frontier', 'MCS', 'R', 'T', 'X', 'S', 
  'F', 'W', 'P', 'N', 'ST', 'SF', 'SW', 'SFW', 'TS', 'TF', 'TW', 'TSW', 'FS', 
  'FT', 'FW', 'FTSW' );
my @advanced_suffix     : shared = ( '-1', '-2', '-3' );
my $advanced_suffix_threshold : shared = 2;

my $advanced_UB_type_index   : shared = 0;
my $advanced_iteration_index : shared = 0;
my $advanced_prefix_index    : shared = 0;
my $advanced_method_index    : shared = 0;
my $advanced_suffix_index    : shared = 0;
my $advanced_iterations_done : shared = 0;

my $method_count : shared = 1;

##############################################################################
#  
##############################################################################

my $trifile_queue  = Thread::Queue->new; 
my $boundary_queue = Thread::Queue->new; 

my $needed_trifiles    = new Thread::Semaphore(0);

my $timing_thread_idle_sem = new Thread::Semaphore(0);
my $timing_thread_idle : shared; 

##############################################################################
# State variables for comparing triangulation methods 
##############################################################################
my $best_sem = new Thread::Semaphore;
my $best_trifile    : shared = 0; 
my $best_partitions : shared = 0; 
my $best_vcap : shared = $initial_vcap; 
my $best_vpap : shared = $initial_vpap; 
my @best_time_per_boundary : shared;

##############################################################################
# Command line parameters 
##############################################################################
my @input_triangulations; 
my $str_file; 
my $timing_script;
my $parallelism;
my $timing_export_line;
my $boundary_export_line;
my $triangulation_export_line;
my $output_directory;
my $str_basename;
my $working_dir;
my $delay_timings;
my $use_existing_boundaries;
my $maximum_boundary_searches;
my $triangulateP;
my $triangulateC;
my $triangulateE;

##############################################################################
# Run the program 
##############################################################################

main();
print "Done Triangulating\n";


##############################################################################
# main 
#
# Evaluate command line parameters and start threads 
##############################################################################
sub main
{
  ##############################################################################
  # Variables for parameters 
  ##############################################################################
  my $valid_options; 
  my $i; 

  ##############################################################################
  # Get command line parameters 
  ##############################################################################
  $valid_options = &GetOptions( 
    "strFile:s"                 => \$str_file, 
    "timingExportLine:s"        => \$timing_export_line,
    "boundaryExportLine:s"      => \$boundary_export_line,
    "triangulationExportLine:s" => \$triangulation_export_line,
    "timingScript:s"            => \$timing_script,
    "parallelism:i"             => \$parallelism,
    "outputDirectory:s"         => \$output_directory,
    "seconds:i"                 => \$timing_length,
    "useExistingBoundaries!"    => \$use_existing_boundaries,
    "maximumBoundarySearches:i" => \$maximum_boundary_searches,
    "delayTimings!"             => \$delay_timings,
    "triangulateP!"             => \$triangulateP,
    "triangulateC!"             => \$triangulateC,
    "triangulateE!"             => \$triangulateE
   );

  @input_triangulations = @ARGV;

  ##########################################################################
  # Process command line parameters
  ##########################################################################

  if (!defined $str_file)
  {
    print "***ERROR:  Must supply a structure file name\n";
    $valid_options = 0;
  }
  else 
  {
    (-e $str_file) or die "***ERROR:  Stucture file '$str_file' does not exist\n"; 
  }

  if (!defined $timing_export_line) 
  {
    $timing_export_line = ' ';
  }

  if (!defined $boundary_export_line) 
  {
    $boundary_export_line = '/bin/bash'; 
  }

  if (!defined $triangulation_export_line) 
  {
    $triangulation_export_line = ' '; 
  }

  if (!defined $timing_script) 
  { 
    print "***ERROR:  Must supply a script which runs gmtkTime\n";
    $valid_options = 0;
  }

  if (!$valid_options) 
  {
    print "Must give:\n";
    print "  1) Structure file which already has a triangulation\n"; 
    print "  2) An export line specifying a particular speed of processor for inference\n";
    print "  3) Scripts which runs gmtkTime (-inputTriangulatedFile, -strFile, and\n";
    print "     -seconds are passed in as parameters)\n"; 
    print "      -strFile                Structure file name\n";
    print "      -timingExportLine       Export line for timings\n";
    print "      -boundaryExportLine     Export line for boundary searches\n";
    print "      -timingScript           Script running gmtkTime\n";
    print "      -inputTriangulatedFile  Starting triangulation\n";
    die "\n";
  }

  if (!defined $timing_script) 
  { 
    print "***ERROR:  Must supply a script which runs gmtkTime\n";
    $valid_options = 0;
  }

  if (! -d $output_directory)  
  {
    print "***ERROR:  '$output_directory' is not a valid directory\n";
    $valid_options = 0;
  }

  if (!defined $use_existing_boundaries) 
  {
    $use_existing_boundaries = 0;  
  }

  if (!defined $triangulateP)
  {
    $triangulateP = 0;
  }

  if (!defined $triangulateC)
  {
    $triangulateC = 0;
  }

  if (!defined $triangulateE)
  {
    $triangulateE = 0;
  }

  if (!defined $parallelism) 
  {
     $parallelism = 1;
  }
    
  if (!defined $output_directory)
  {
die;
    $output_directory = './';
  }

  if (!defined $delay_timings) 
  {
    $delay_timings = 0;
  }

  ($valid_options) or die "Options not valid\n";

  $str_basename = basename($str_file); 
  $working_dir = `pwd`;

  chomp($working_dir);

  for ($i=0; $i<60; $i++)
  {
    $best_time_per_boundary[$i] = 0;
  }

  STDOUT->autoflush(1);
  $SIG{PIPE} = 'IGNORE';


print "P:$triangulateP\n";
print "C:$triangulateC\n";
print "E:$triangulateE\n";

  #############################################################################
  # Start the threads 
  #############################################################################
  my $last_child;

  print "------- Triangulating $str_file -------\n"; 

  ########################################################################### 
  # Start boundary searches 
  ########################################################################### 
  if ((!$use_existing_boundaries) &&
      ($triangulateC))
  {
    $last_child = threads->new( \&start_boundary_searches );
  }

  ########################################################################### 
  # If requested, delay the timing and triangulation threads to make sure 
  #  boundary searches have a chance to get processors 
  ########################################################################### 
  if ((!$use_existing_boundaries) &&
      ($triangulateC)             &&
      ($delay_timings)) 
  { 
    sleep(60);
    print "Starting timing threads\n";
  }

  #########################################################################
  # Start thread to generate triangulations 
  #########################################################################
  $last_child = threads->new( \&generate_triangulations );

  #########################################################################
  # Get list of boundary files (if not generating boundaries) 
  #########################################################################
  if ($use_existing_boundaries)
  {
    threads->yield;
    sleep(1);
    get_existing_boundaries();
  }

  #########################################################################
  # Start threads to time triangulations
  #########################################################################
  for (my $i=0; $i<$parallelism; $i++) {
    $last_child = threads->new(\&time_triangulation, $initial_vpap, 
      $initial_vcap);
  }

  #########################################################################
  # Timing threads never return
  #########################################################################
  $last_child->join;

}


#############################################################################
# generate_triangulations() 
#
# Thread which creates triangulations.  It attempts to keep a queue of 
# triangulations ready for the timing processes. 
#############################################################################
sub generate_triangulations 
{
  my $input_triangulation;
  my @input_trifile_names;
  my $output_triangulation;
  my $input_basename;
  my $i;
  my $prvs_bndry;
  my $bndry_unique;
  my $boundary_count;
  my $total_boundary_count;
  my $boundary_name;
  my $boundary;
  my $method;
  my $method_name;
  my $best_from_previous_section;
  my $triangulation_mode;
  my $vpap_index;
  my $vcap_index;
  my $trifile_name;
  my @boundary_list; 
  my @basic_methods; 

  my @vpap_options : shared = ('COI', 'COB', 'CDOI', 'CODI', 'DOI', 'I' );
  my @vcap_options : shared = ('COI', 'COB', 'CDOI', 'CODI', 'DOI', 'I' );

  ###########################################################################
  # Generate more trifiles than the timing parallelism so one is always
  # likely to be ready when needed. 
  ###########################################################################
  #$needed_trifiles->up( $parallelism/2 );
  $needed_trifiles->up( 1 );

  #######################################################################
  # Get list of basic methods for use later on 
  #######################################################################
  reset_basic_methods();
  
  ($method, $method_name) = get_basic_triangulation_method();
  while ($method_name ne 'DONE')
  {
    push @basic_methods, $method_name;
    ($method, $method_name) = get_basic_triangulation_method();
  }
  
  #######################################################################
  # Triangulate the Chunk 
  #######################################################################
  if ($triangulateC) 
  {
    $triangulation_mode = 'C'; 

    ###########################################################################
    # Phase 1, put the input triangulations on the queue 
    ###########################################################################
    $i = 0;
    foreach $input_triangulation (@input_triangulations) 
    {
      $input_basename = basename($input_triangulation); 
  
      if (-e $input_triangulation) 
      {
        $output_triangulation = "$output_directory/input.$i.$input_basename";
        copy( $input_triangulation, $output_triangulation ); 
        push @input_trifile_names, $output_triangulation;
  
        $trifile_queue->enqueue($output_triangulation);
  
        $needed_trifiles->down;
  
        $boundary_queue->enqueue( $output_triangulation );
      }
  
      $i++;
    }

    ###########################################################################
    # Phase 2, run basic methods on all boundaries 
    ###########################################################################
    $boundary_count=0; 
    while ( !$boundary_searches_done )
    {
      $boundary = $boundary_queue->dequeue;
    
      if ($boundary eq 'BOUNDARY_SEARCHES_DONE' ) 
      {
        $boundary_searches_done = 1;
      }
      else 
      {
        #####################################################################
        # Check to see if the boundary is unique 
        #####################################################################
        $bndry_unique = 1;
  
        if ($boundary_count >= (scalar @input_triangulations)) 
        { 
          for( $prvs_bndry = 0; 
               ($prvs_bndry<(scalar @boundary_list)) && ($bndry_unique); 
               $prvs_bndry++)
          {
            $bndry_unique = boundary_files_ne( 
              $boundary_list[$prvs_bndry]->{NAME}, $boundary );
          }
        }
  
        #####################################################################
        # If the boundary is unique, add to list and run the basic methods 
        #####################################################################
        if ($bndry_unique) 
        {
          $boundary_name = "B$boundary_count";
          push @boundary_list, my $bnd = {NAME=>$boundary, SPEED=>0, 
            INDEX=>$boundary_count};
  
          print "$boundary_name ==> Boundary from '$boundary'\n";
  
          reset_basic_methods();
  
          ($method, $method_name) = get_basic_triangulation_method();
          while ($method_name ne 'DONE')
          {
            make_trifile( $boundary_name, $boundary, $method_name, $method, 
              $triangulation_mode );
            ($method, $method_name) = get_basic_triangulation_method();
          }
  
          $boundary_count++;
        }
      }
    } # end while
  
    ###########################################################################
    # Wait for all triangulations in the queue to be triangulated 
    #
    # Lock the timing_thread_idle variable 
    # Queue a copy of BECOME_IDLE for each timing thread
    # Decrement the timing_thread_idle_sem once for each timing thread (the
    #   timing threads will increment it as they process BECOME_IDLE)
    # The timing_thread_idle variable is unlocked, telling the timing threads  
    #   to they can continue
    ###########################################################################
    {
      lock($timing_thread_idle);
      for ($i=0; $i<$parallelism; $i++) {
        $trifile_queue->enqueue('BECOME_IDLE');
      }
      $timing_thread_idle_sem->down($parallelism); 
    }
  
    print "Found $boundary_count unique boundaries\n";
  
    print "---------- Beginning triangulation using advanced option set ----------\n";
  
    ###########################################################################
    # Sort the boundaries by their performance on the basic triangulations
    ###########################################################################
    for($i=0; $i<(scalar @boundary_list); $i++)
    {
      $boundary_list[$i]->{SPEED} = $best_time_per_boundary[$i];
    }
  
    @boundary_list = sort { $b->{SPEED} <=> $a->{SPEED} } @boundary_list;
  
    ###########################################################################
    # Phase 3, 
    ###########################################################################
    for ( $boundary_count = 0; 
          $boundary_count < (scalar @boundary_list); 
          $boundary_count++ )
    {
      $boundary = $boundary_list[$boundary_count]->{NAME};
      $boundary_name = "B$boundary_list[$boundary_count]->{INDEX}";
  
      print "------ Starting $boundary_name ------\n";
  
      #######################################################################
      # Run advanced methods (minus the basic methods) using initial vcap
      #   and vpap  
      #######################################################################
      reset_advanced_methods();
  
      ($method, $method_name) = get_advanced_triangulation_method();
  
      while ($method_name ne 'DONE')
      {
        if (!grep /^$method_name$/, @basic_methods) 
        {
          make_trifile( $boundary_name, $boundary, $method_name, $method, 
            $triangulation_mode );
        }
  
        ($method, $method_name) = get_advanced_triangulation_method();
      }
  
      #######################################################################
      # Now run all methods using various combinations of vpap and vcap
      #######################################################################
      for ($vpap_index=0; $vpap_index<(scalar @vpap_options); $vpap_index++)
      {
        for ($vcap_index=0; $vcap_index<(scalar @vcap_options); $vcap_index++)
        {
          if (($vpap_index == 0) && ($vcap_index == 0)) 
          {
            $vcap_index++;
          }
  
          {
            lock($timing_thread_idle);
            for ($i=0; $i<$parallelism; $i++) {
              $trifile_queue->enqueue("RESTART_${vpap_options[$vpap_index]}_${vcap_options[$vcap_index]}");
            }
            $timing_thread_idle_sem->down($parallelism); 
          }
  
          ###############################################################
          # Input triangulations  
          ###############################################################
          foreach $trifile_name (@input_trifile_names)
          {
            $trifile_queue->enqueue($trifile_name);
            $needed_trifiles->down; 
          }
  
          ###############################################################
          # Advanced triangulation methods  
          ###############################################################
          reset_advanced_methods();
  
          ($method, $method_name) = get_advanced_triangulation_method();
          while ($method_name ne 'DONE')
          { 
            $trifile_name = "$output_directory/$boundary_name.$method_name.$str_basename.trifile"; 
            $trifile_queue->enqueue($trifile_name);
            $needed_trifiles->down; 
            ($method, $method_name) = get_advanced_triangulation_method();
          } 
        } 
      } 
  
      #######################################################################
      # Restart gmtkTime using initial vpap and vcap 
      #######################################################################
      {
        lock($timing_thread_idle);
        for ($i=0; $i<$parallelism; $i++) {
          $trifile_queue->enqueue("RESTART_${initial_vpap}_${initial_vcap}");
        }
        $timing_thread_idle_sem->down($parallelism); 
      }
  
    } # for boundary_list
  } # if triangulate C

  ###########################################################################
  # If C wasn't triangulated on this run, find the fastest input 
  # triangulation and fastest timing option  
  ###########################################################################
  if (!$triangulateC)
  {
    for ($vpap_index=0; $vpap_index<(scalar @vpap_options); $vpap_index++)
    {
      for ($vcap_index=0; $vcap_index<(scalar @vcap_options); $vcap_index++)
      {
        if (($vpap_index == 0) && ($vcap_index == 0)) 
        {
          $vcap_index++;
        }

        $i = 0; 
        foreach $input_triangulation (@input_triangulations) 
        {
          $input_basename = basename($input_triangulation);
 
          if (-e $input_triangulation) 
          {
            $output_triangulation = 
              "$output_directory/input.$i.$input_basename";
            copy( $input_triangulation, $output_triangulation ); 
            push @input_trifile_names, $output_triangulation;
      
            $trifile_queue->enqueue($output_triangulation);
            $needed_trifiles->down;
            $boundary_queue->enqueue( $output_triangulation );
          }
          $i++ 
        }

        #######################################################################
        # Restart gmtkTime using new vpap and vcap 
        #######################################################################
        {
          lock($timing_thread_idle);
          for ($i=0; $i<$parallelism; $i++) {
            $trifile_queue->enqueue("RESTART_${vpap_options[$vpap_index]}_${vcap_options[$vcap_index]}");
          }
          $timing_thread_idle_sem->down($parallelism); 
        }

      }
    }
  }

  $best_from_previous_section = "$output_directory/after_C_search.trifile";
  copy( $best_trifile, $best_from_previous_section );
 
  #######################################################################
  # Restart gmtkTime using best vpap and vcap 
  #######################################################################
  {
    lock($timing_thread_idle);
    for ($i=0; $i<$parallelism; $i++) {
      $trifile_queue->enqueue("RESTART_${best_vpap}_${best_vcap}");
    }
    $timing_thread_idle_sem->down($parallelism); 
  }

  #######################################################################
  # Triangulate Epilogue  
  #######################################################################
  if ($triangulateE) 
  {
    print "------------- Triangulating E -------------\n"; 
    $triangulation_mode = 'E';
    $boundary      = $best_from_previous_section; 
    $boundary_name = 'BE'; 

    #######################################################################
    # Run basic methods 
    #######################################################################
    reset_basic_methods();
  
    ($method, $method_name) = get_basic_triangulation_method();
    while ($method_name ne 'DONE')
    {
      make_trifile( $boundary_name, $boundary, $method_name, $method, 
        $triangulation_mode );
      ($method, $method_name) = get_basic_triangulation_method();
    }

    #######################################################################
    # Run advanced methods (minus the basic methods) using initial vcap
    #   and vpap  
    #######################################################################
    reset_advanced_methods();

    ($method, $method_name) = get_advanced_triangulation_method();
    while ($method_name ne 'DONE')
    {
      if (!grep /^$method_name$/, @basic_methods) 
      {
        make_trifile( $boundary_name, $boundary, $method_name, $method, 
          $triangulation_mode );
      }
      ($method, $method_name) = get_advanced_triangulation_method();
    }
  }

  $best_from_previous_section = "$output_directory/after_E_search.trifile";
  copy( $best_trifile, $best_from_previous_section );
 
  #######################################################################
  # Triangulate Prologue 
  #######################################################################
  if ($triangulateP) 
  {
    print "------------- Triangulating P -------------\n"; 
    $triangulation_mode = 'P';
    $boundary      = $best_from_previous_section; 
    $boundary_name = 'BP'; 

    #######################################################################
    # Run basic methods 
    #######################################################################
    reset_basic_methods();
  
    ($method, $method_name) = get_basic_triangulation_method();
    while ($method_name ne 'DONE')
    {
      make_trifile( $boundary_name, $boundary, $method_name, $method, 
        $triangulation_mode );
      ($method, $method_name) = get_basic_triangulation_method();
    }

    #######################################################################
    # Run advanced methods (minus the basic methods) using initial vcap
    #   and vpap  
    #######################################################################
    reset_advanced_methods();

    ($method, $method_name) = get_advanced_triangulation_method();
    while ($method_name ne 'DONE')
    {
      if (!grep /^$method_name$/, @basic_methods) 
      {
        make_trifile( $boundary_name, $boundary, $method_name, $method, 
          $triangulation_mode );
      }
      ($method, $method_name) = get_advanced_triangulation_method();
    }
  }

  print "Done generating triangulations\n"; 
}


#############################################################################
# time_triangulation() 
#
# Thread which fetches a method, runs a triangulation, and times it
#############################################################################
sub time_triangulation 
{
  my $vpap;
  my $vcap;
  my $crrnt_pid;
  my $timing_script_input;
  my $timing_script_output;
  my $processing_command;
  my $crrnt_partitions;
  my $trifile_name;
  my $boundary;
  my $method;

  $vcap = pop;
  $vpap = pop;

  #####################################################################
  # Open a copy of gmtkTime in multiTest mode 
  #####################################################################
  $timing_script_input  = gensym;
  $timing_script_output = gensym;

  ($crrnt_pid, $timing_script_input, $timing_script_output) = open_time(
    "-vpap $vpap -vcap $vcap" );

  #####################################################################
  # Generate and time triangulations 
  #####################################################################
  while (1) 
  {
    #####################################################################
    # Get the next trifile from the queue 
    #####################################################################
    $needed_trifiles->up;

    do 
    {
      $trifile_name = $trifile_queue->dequeue;

      $processing_command = 0;

      if ($trifile_name eq 'BECOME_IDLE') 
      {
        $processing_command = 1;
      }
      elsif ($trifile_name =~ /RESTART_/) 
      {
        ($vpap, $vcap) = $trifile_name =~ /RESTART_(.+)_(.+)/; 

        close $timing_script_input;
        close $timing_script_output;
        waitpid $crrnt_pid, 0; 
        ($crrnt_pid, $timing_script_input, $timing_script_output) = open_time(
          "-vpap $vpap -vcap $vcap" );

        $processing_command = 1;
      }

      if ($processing_command) 
      {
        $timing_thread_idle_sem->up;
        lock($timing_thread_idle);
      }

    } while ($processing_command); 

    #####################################################################
    # Time the trifile 
    #####################################################################
    ($crrnt_pid, $timing_script_input, $timing_script_output, 
      $crrnt_partitions) = run_timing( $crrnt_pid, $timing_script_input, 
      $timing_script_output, $trifile_name, "-vpap $vpap -vcap $vcap" );

    check_best($crrnt_partitions, $vpap, $vcap, $trifile_name);

  } 

}


#############################################################################
# open_time( );
#
#############################################################################
sub open_time
{
  my $options;
  my $error;
  my $output;
  my $pid;
  my $timing_script_input;
  my $timing_script_output;

  $options = pop;

  do {
    $error = 0;
    eval 
    {
      $pid = open2( $timing_script_output, $timing_script_input, "$timing_export_line $timing_script -strFile $str_file -seconds $timing_length -multiTest T 2>&1 ");

      $timing_script_input->autoflush(1);
      $output = <$timing_script_output>;
      print STDERR "$output";
    };

    if ($@ || ($output=~'no suitable host available')) 
    { 
      $error = 1;
      chomp($output);
      if ( !$boundary_searches_done ) {
        sleep(60);
      }
      else {
        print "Problem opening timing script:'$output'\n";
      }
      waitpid $pid, 0; 
      sleep(15);
    }

  } while ($error);

  return ($pid, $timing_script_input, $timing_script_output);
}


#############################################################################
# get_existing_boundaries 
#############################################################################
sub get_existing_boundaries
{
  my @boundary_list;
  my $boundary;
  my $total_boundaries;

  opendir WORK_DIR, "$output_directory" or die 
    "***Error: Can't open triangulation work directory: $output_directory";
  @boundary_list = grep /.*\.boundary$/, readdir WORK_DIR; 
  closedir WORK_DIR;

  $total_boundaries = 0; 
  foreach $boundary (@boundary_list)
  {
    $boundary_queue->enqueue("$output_directory/$boundary");
    $total_boundaries++; 
  }
  
  printf "%d boundary files found\n", $total_boundaries; 

##sleep(30); ### !!!!! turn this into a lock
  $boundary_queue->enqueue( 'BOUNDARY_SEARCHES_DONE' ); 
}


#############################################################################
# start_boundary_searches 
#
# do boundary searches 
#############################################################################
sub start_boundary_searches 
{
  my @boundary_heuristics;
  my $boundary_heuristic;
  my $boundary_job_list;
  my $triangulate_line;
  my @weight_UB_types;
  my $weight_UB_type;
  my $left_right;
  my $output_name;
  my $boundary_calls;
  my $total_boundaries;

  @boundary_heuristics = ('W' , 'Q', 'A', 'FWH', 'S', 'T', 'F', 'P', 'N', 'ST',
    'SF', 'SW', 'SFW', 'TS', 'TF', 'TW', 'TSW', 'FS', 'FT', 'FW', 'FTSW');

  ############################################################################
  # Create makefile for boundaries  
  ############################################################################
  $boundary_job_list = "$output_directory/boundary_job_list";  

  $triangulate_line = "$gmtk_triangulate -strFile $str_file -rePartition T -reTriangulate T -findBestBoundary T -seed T -printResults F -numBackupFiles 0 -anyTimeTriangulate '4hour' -noBoundaryMemoize T -jtWeight T";
  ##$triangulate_line = "$gmtk_triangulate -strFile $str_file -rePartition T -reTriangulate T -findBestBoundary T -seed T -printResults F -numBackupFiles 0 -anyTimeTriangulate '4hour' -noBoundaryMemoize T -jtWeight F";
 
  open JOB_LIST, ">$boundary_job_list";

  $boundary_calls = 0;
  foreach $boundary_heuristic (@boundary_heuristics)
  {
    if ($boundary_heuristic =~ /W/) {
      @weight_UB_types = ('F', 'T');
    }
    else {
      @weight_UB_types = ('F');
    }

    foreach $weight_UB_type (@weight_UB_types)
    {
      foreach $left_right ('L', 'R') 
      {
        if ((!defined $maximum_boundary_searches) || 
            ($boundary_calls < $maximum_boundary_searches))
        { 
          $output_name = "$output_directory/$boundary_heuristic.$weight_UB_type.$left_right.$str_basename.boundary";
          print JOB_LIST "$triangulate_line -outputTriangulatedFile $output_name -boundaryHeuristic $boundary_heuristic -jtwUB $weight_UB_type -forceLeftRight $left_right 2>&1 ; echo DONE WITH $output_name\n";
          $boundary_calls++;
        }
      }
    }
  }

  close JOB_LIST; 

  ############################################################################
  # Start searches and enque the boundaries as they finish
  ############################################################################
  open RUN_JOBS, "cat $boundary_job_list | $boundary_export_line |";

  $total_boundaries = 0; 
  while (<RUN_JOBS>) 
  {
    print STDERR "$_";

    ($output_name) = $_ =~ /^DONE WITH (\S+)$/; 

    if (defined $output_name) 
    {
      $boundary_queue->enqueue($output_name);
      $total_boundaries++; 
    }
  }

  close RUN_JOBS;
  
  printf "%d boundary searches completed\n", $total_boundaries; 

  $boundary_queue->enqueue( 'BOUNDARY_SEARCHES_DONE' ); 
}


#############################################################################
# run_triangulation( method );
#
# Triangulates the graph according to the method parameter
#############################################################################
sub run_triangulation
{
  my $method_options;
  my $boundary;
  my $output;
  my $jt_weight;
  my $output_tri_file;
  my $triangulation_mode;
  my $triangulation_mode_string;

  $triangulation_mode = pop;
  $output_tri_file = pop;
  $boundary        = pop;
  $method_options  = pop;

  if ($triangulation_mode eq 'P') {
    $triangulation_mode_string = '-noReTriP F -noReTriC T -noReTriE T'; 
  }
  elsif ($triangulation_mode eq 'C') {
    $triangulation_mode_string = '-noReTriP T -noReTriC F -noReTriE T'; 
  }
  elsif ($triangulation_mode eq 'E') {
    $triangulation_mode_string = '-noReTriP T -noReTriC T -noReTriE F'; 
  }
  else {
    die "***INTERNAL ERROR, invalid triangulation_mode"; 
  }

  $output = `$triangulation_export_line $gmtk_triangulate -strFile $str_file -rePartition F -reTriangulate T -findBestBoundary F -inputTriangulatedFile $boundary -seed T -outputTriangulatedFile $output_tri_file -printResults T -numBackupFiles 0 $method_options $triangulation_mode_string -jtWeight T 2>&1`;

  print STDERR "$output\n";

  ($jt_weight) = $output =~ /Chunk max clique weight =.* jt_weight = ([0-9.]+)/;

  if (!defined $jt_weight) {
    $jt_weight = 0; 
  }
  else {
    $jt_weight = 1; 
  }

  return($jt_weight); 
}

#############################################################################
# make_trifile 
#
# Create a trifile with given method and adjust the trifile queues
#############################################################################
sub make_trifile
{
  my $boundary;
  my $boundary_name;
  my $method_name;
  my $method_options;
  my $thread_id;
  my $triangulation_mode;

  $triangulation_mode = pop;
  $method_options = pop;
  $method_name    = pop;
  $boundary       = pop;
  $boundary_name  = pop;

  $needed_trifiles->down;

  $thread_id = threads->new( \&make_trifile_thread, $boundary_name, $boundary, 
    $method_name, $method_options, $triangulation_mode );
  $thread_id->detach;  
  
#  make_trifile_thread( $boundary_name, $boundary, $method_name, $method_options, $triangulation_mode );

}


#############################################################################
# make_trifile_thread 
#############################################################################
sub make_trifile_thread
{
  my $boundary;
  my $boundary_name;
  my $file_h;
  my $method_options;
  my $method_name;
  my $tmp_tri_file;
  my $triangulation_mode;
  my $triangulation_status;

  $triangulation_mode = pop;
  $method_options = pop;
  $method_name    = pop;
  $boundary       = pop;
  $boundary_name  = pop;

  $tmp_tri_file = "$output_directory/$boundary_name.$method_name.$str_basename.trifile";

  do {
    $triangulation_status = run_triangulation($method_options, $boundary, 
      $tmp_tri_file, $triangulation_mode );
    if ($triangulation_status < 0) {
      print "Triangulation failed\n";
      sleep(15);
    } 
  } while($triangulation_status< 0);

  $trifile_queue->enqueue($tmp_tri_file);
}


#############################################################################
# reset_basic_methods();
#
# Reset the counters that keep track of the current basic method 
#############################################################################
sub reset_basic_methods 
{
  $basic_once_index = 0;
  $basic_iteration_index = 0;
  $basic_prefix_index    = 0;
  $basic_method_index    = 0;
  $basic_suffix_index    = 0;
  $basic_iterations_done = 0;
}

#############################################################################
# get_triangulation_method( method );
#
# Get triangulation method from the circular queue  
#############################################################################
sub get_basic_triangulation_method  
{
  my $method;
  my $method_line;
  my $method_name;

  if ($basic_iterations_done) { 
    $method_line = 'DONE';
    $method_name = 'DONE';
  }
  elsif ($basic_once_index < (scalar @run_once)) {
    $method = $run_once[$basic_once_index];
    $method_line = "-triangulationHeuristic $method"; 
    $method_name = "$method.F"; 

    $basic_once_index++;
  }
  else 
  {
    $method = "$basic_iterations[$basic_iteration_index]$basic_prefix[$basic_prefix_index]$basic_method[$basic_method_index]";

    if ($basic_method_index >= $basic_suffix_threshold) {
      $method = "$method$basic_suffix[$basic_suffix_index]";
    }

    $method_line = "-triangulationHeuristic $method"; 
    $method_name = "$method.F"; 

    #########################################################################
    # Increment the method indices
    #########################################################################
    if ($basic_method_index >= $basic_suffix_threshold) {
      $basic_suffix_index++;
      if ($basic_suffix_index >= (scalar @basic_suffix)) {
        $basic_suffix_index = 0;
        $basic_method_index++;
      }
    }

    if ($basic_method_index < $basic_suffix_threshold) {
      $basic_method_index++;
    }

    if ($basic_method_index >= (scalar @basic_method)) {
      $basic_method_index = 0;
      $basic_prefix_index++;
      if ($basic_prefix_index >= (scalar @basic_prefix)) {
        $basic_prefix_index = 0;
        $basic_iteration_index++;
        if ($basic_iteration_index >= (scalar @basic_iterations)) {
          $basic_iteration_index = 0;
          $basic_iterations_done = 1; 
        }
      }
    } 
  }

  return($method_line, $method_name);
}

#############################################################################
# reset_advanced_methods();
#
# Reset the counters that keep track of the current basic method 
#############################################################################
sub reset_advanced_methods 
{
  $advanced_once_index      = 0; 
  $advanced_UB_type_index   = 0;
  $advanced_iteration_index = 0;
  $advanced_prefix_index    = 0;
  $advanced_method_index    = 0;
  $advanced_suffix_index    = 0;
  $advanced_iterations_done = 0;
}

#############################################################################
# get_triangulation_method( method );
#
# Get triangulation method from the circular queue  
#############################################################################
sub get_advanced_triangulation_method  
{
  my $method;
  my $method_line;
  my $method_name;
  my $other_method_options;

  if ($advanced_iterations_done) 
  { 
    $method_line = 'DONE';
    $method_name = 'DONE';
  }
  else 
  {
    if ($advanced_once_index < (scalar @run_once)) 
    {
      $method = $run_once[$advanced_once_index];

      $method_line = "-triangulationHeuristic $method -jtwUB $advanced_UB_types[$advanced_UB_type_index]";
      $method_name = "${method}.$advanced_UB_types[$advanced_UB_type_index]";

      $advanced_UB_type_index++;
      if ($advanced_UB_type_index >= (scalar @advanced_UB_types)) 
      {
        $advanced_UB_type_index=0;
        $advanced_once_index++;
      }
    }
    else 
    {
      $method = "$advanced_iterations[$advanced_iteration_index]$advanced_prefix[$advanced_prefix_index]$advanced_method[$advanced_method_index]"; 

      if ($advanced_method_index >= $advanced_suffix_threshold) 
      {
        $method = "$method$advanced_suffix[$advanced_suffix_index]";
      }

      $method_line = "-triangulationHeuristic $method -jtwUB $advanced_UB_types[$advanced_UB_type_index]";
      $method_name = "${method}.$advanced_UB_types[$advanced_UB_type_index]";

      #################################################################
      # Increment the method indices
      #################################################################
      $advanced_UB_type_index++;
      if ($advanced_UB_type_index >= (scalar @advanced_UB_types)) 
      {
        $advanced_UB_type_index=0;

        if ($advanced_method_index >= $advanced_suffix_threshold) 
        {
          $advanced_suffix_index++;
          if ($advanced_suffix_index >= (scalar @advanced_suffix)) 
          {
            $advanced_suffix_index = 0;
            $advanced_method_index++;
          }
        }

        if ($advanced_method_index < $advanced_suffix_threshold) 
        {
          $advanced_method_index++;
        }

        if ($advanced_method_index >= (scalar @advanced_method)) 
        {
          $advanced_method_index = 0;
          $advanced_prefix_index++;
          if ($advanced_prefix_index >= (scalar @advanced_prefix)) 
          {
            $advanced_prefix_index = 0;
            $advanced_iteration_index++;
            if ($advanced_iteration_index >= (scalar @advanced_iterations)) 
            {
              $advanced_iteration_index = 0;
              $advanced_iterations_done = 1; 
            }
          }
        }
      } 
    }
  } 

  return($method_line, $method_name);
}

#############################################################################
# run_timing 
#
#############################################################################
sub run_timing 
{
  my $timing_options;
  my $tri_file;
  my $output;
  my $partitions;

  my $crrnt_pid; 
  my $timing_script_input; 
  my $timing_script_output; 
  my $error_found; 

  $timing_options = pop;
  $tri_file       = pop;
  $timing_script_output = pop; 
  $timing_script_input  = pop; 
  $crrnt_pid            = pop; 

  do { 
    $error_found = 0;
    eval {
      print $timing_script_input "$tri_file\n";
    
      ##########################################################################
      # Read in pre timing output:
      #   cpp warnings ....        
      #   exported to ....        # not needed if not exporting  
      #   --------
      #   0: Operating on trifile ''
      #   0: Running program for approximately 7 seconds
      ##########################################################################
      do {
        $output = <$timing_script_output>;
        (defined $output) or die;
        print STDERR "$output";
        chomp($output);
      } while($output ne '--------');
    
      $output = <$timing_script_output>;
      (defined $output) or die;
      print STDERR "$output";
      $output = <$timing_script_output>;
      (defined $output) or die;
      print STDERR "$output";
    };
   
    ###########################################################################
    # An error at this point means that the trifile can't be sent to gmtkTime,
    # so restart the process
    ###########################################################################
    if ($@) {
      waitpid $crrnt_pid, 0; 
      ($crrnt_pid, $timing_script_input, $timing_script_output) = open_time( 
        $timing_options );
      $error_found = 1;
    } 

  } while($error_found);
 
  ###########################################################################
  # Read in timing results:
  #   User: 6.980000, System: 0.030000, CPU 7.010000
  #   0: Inference stats: 6.98...
  ###########################################################################
  eval {
    $output = <$timing_script_output>;
    (defined $output) or die;
    print STDERR "$output";

    if (!($output =~ /NOTICE/)) {
      $output = <$timing_script_output>;
      (defined $output) or die;
      print STDERR "$output";
    }

    ($partitions) = $output =~ /, ([0-9+-.e]+) partitions\/sec/;
  };

  (defined $partitions) or $partitions = -1; 

  return($crrnt_pid, $timing_script_input, $timing_script_output, $partitions );
}


#############################################################################
# check_best 
#
#############################################################################
sub check_best 
{
  my $method;
  my $boundary;
  my $boundary_index;
  my $tmp;
  my $nmbr_partitions;
  my $vpap;
  my $vcap;
  my $trifile_name;
  my $overall_best_flag;

  $trifile_name    = pop;
  $vcap            = pop;
  $vpap            = pop;
  $nmbr_partitions = pop;

  $best_sem->down;

  ($method) = $trifile_name =~ /(input\.\d+\.[^\/]+)$/; 
  if (! defined $method) {
    ($method) = $trifile_name =~ /B[0-9PE]+.([^\/]+)\.$str_basename/;
  }

  ($tmp, $boundary_index) = $trifile_name =~ /(^|\/)B([0-9PE]+)\./;
  $tmp = '';
  if (!defined $boundary_index) {
    ($boundary_index) = $method =~ /input\.(\d+)\./;
  }

  $boundary = "B$boundary_index";

  printf "%-4s%-39s%-5s%-5s%4e", $boundary, $method, $vpap, $vcap, 
    $nmbr_partitions;

  if ($nmbr_partitions > $best_partitions) {
    print " => BEST!!!";
    $best_partitions = $nmbr_partitions;
    $best_vpap = $vpap;
    $best_vcap = $vcap;
    $best_trifile = "$str_basename.best.trifile";
    copy( $trifile_name, $best_trifile ); 
    $overall_best_flag = 1;
  }
  else {
    $overall_best_flag = 0;
  }

  if (($boundary_index ne 'P') && 
      ($boundary_index ne 'E') && 
      ($nmbr_partitions > $best_time_per_boundary[$boundary_index]))
  {
    if (!$overall_best_flag) {
      print " => bndry. best";
    }
  
    $best_time_per_boundary[$boundary_index] = $nmbr_partitions;
  }
 
  print "\n";

  $best_sem->up;
}

#############################################################################
# get_seconds(timestring)
#
# The input is a time string specifying:  seconds, minutes, hours, days, 
#    weeks.  Examples: 
#    '3 seconds 4 minutes 1 hour'  
#    '4min 1 hour 2 days'  
#    '1w3s1h'  
#
# Output is the integer number of seconds represented by the string.
#############################################################################
sub get_seconds 
{
  my $time_string;
  my @strings;
  my $total;
  my $string;
  my $numbers;
  my $letters;
  my $scnds;
  
  $time_string = pop;

  (@strings) = split /(\d+\s*\w+)/, $time_string;

  $total = 0;

  foreach $string (@strings)
  {
    ($numbers, $letters) = $string =~ /(\d+)\s*(\w+)/;

    if ((defined $letters) && (defined $numbers) &&  
        ('seconds' =~ /$letters/)) {
      $total = $total + $numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('minutes' =~ /$letters/)) {
      $total = $total + 60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('hours' =~ /$letters/)) {
      $total = $total + 60*60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('days' =~ /$letters/)) {
      $total = $total + 24*60*60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('weeks' =~ /$letters/)) {
      $total = $total + 7*24*60*60*$numbers;
    }
  }

  return $total;
}


#############################################################################
# boundary_files_ne 
#
# 
#############################################################################
sub boundary_files_ne
{
  my $trifile_1;
  my $trifile_2;
  my @boundary_1;
  my @boundary_2;
  my $boundaries_ne;
  my $i;

  $trifile_2 = pop;
  $trifile_1 = pop;

  @boundary_1 = load_boundary( $trifile_1 );
  @boundary_2 = load_boundary( $trifile_2 );

  $boundaries_ne = 0;

  if ((scalar @boundary_1) != (scalar @boundary_2)) {
    $boundaries_ne = 1;
  }

  for ( $i=0; 
        ($i<(scalar @boundary_1)) && (!$boundaries_ne); 
        $i++ ) 
  {
    if ($boundary_1[$i] ne $boundary_2[$i]) {
      $boundaries_ne = 1;
    }
  }

  return($boundaries_ne);
}


#############################################################################
# load_boundary
#
# 
#############################################################################
sub load_boundary 
{
  my $trifile;
  my @trifile;
  my @trifile_boundary;
  my @interface_method;
  my $interface_method;
  my @tokens; 
  my $nmbr_variables; 
  my @variables; 
  my $variable_name; 
  my $frame; 

  $trifile = pop;

  open TRIFILE, "<$trifile" or die "***Error: Couldn't open trifile $trifile"; 
  @trifile = <TRIFILE>;
  close TRIFILE;

  @trifile_boundary = grep /^PC_PARTITION/, @trifile;
  @interface_method = grep /^(RIGHT|LEFT)\s*$/, @trifile;
  $interface_method = "@interface_method"; 
  chomp $interface_method; 

  ((scalar @interface_method) == 1) or die 
    "Something is wrong with trifile $trifile, perhaps trifile is incomplete\n";

  @tokens = split /\s+/, "@trifile_boundary";

  (((scalar @trifile_boundary)==1) && ((shift @tokens) eq 'PC_PARTITION')) or 
    die "Something is wrong with trifile $trifile, perhaps a variable name PC_PARTITION\n";

  $nmbr_variables = shift @tokens;

  ($nmbr_variables > 0) or die "Something is wrong with trifile $trifile\n";

  while (@tokens) 
  {
    $variable_name = shift @tokens; 
    $frame = shift @tokens;

    ((defined $variable_name) && (defined $frame)) or die 
      "Something is wrong with trifile $trifile";
 
    push @variables, "${variable_name}__${frame}";     
  }

  @variables = sort @variables;

  return($interface_method, @variables);
}


