#!/usr/nikola/bin/perl -w
# $Header$

use strict;
use File::Basename;
use File::Copy;
use File::Temp qw/ tempfile tempdir /;
use Getopt::Long;
use IO::Handle; 
use IPC::Open2; 
use Symbol; 
use threads; 
use Thread::Semaphore;

##############################################################################
# Variables for parameters 
##############################################################################
my $valid_options; 
my $str_file; 
my $timing_script;
my $parallelism;
my $export_line;
my $input_triangulation;
my $timing_length; 
my $str_basename;
my $working_dir;

##############################################################################
# Executable names (should eventually be overwritten by command line 
# parameters)
##############################################################################
my $gmtk_triangulate;
my $pmae;
my $pmake;

##############################################################################
# State variables for method queue 
##############################################################################
my $done_initial    : shared = 0;
my $once_index      : shared = 0;

my @run_once = ( 'completed', 'elimination-heuristics', 
  'non-elimination-heuristics' );

my @iterations = ( '100-', '10-', '1-' ); 
my @prefix     = ( '', 'pre-edge-lo-', 'pre-edge-all-', 'pre-edge-random-');
my @method     = ( 'frontier', 'MCS', 'R', 'W', 'F' );
my @suffix     = ( '', '-2', '-3' );

my $suffix_threshold = 3;

my $iteration_index : shared = 0;
my $prefix_index    : shared = 0;
my $method_index    : shared = 0;
my $suffix_index    : shared = 0;
  
my $method_sem = new Thread::Semaphore;
my $initial_sem = new Thread::Semaphore;
my $initial_tri_timed : shared = 0;

my $method_count : shared = 1;

my $start_time : shared = 0;

##############################################################################
# State variables for comparing triangulation methods 
##############################################################################
my $best_partitions : shared = 0; 
my $best_sem = new Thread::Semaphore;

##############################################################################
# GMTK tool names
# -Do not add paths to these definitons, alter your path instead
##############################################################################
$gmtk_triangulate = 'gmtkTriangulate'; 
$pmae             = 'pmae'; 
$pmake            = 'pmake'; 

$timing_length = 30; 
#$timing_length = 5; 

##############################################################################
# Get command line parameters 
##############################################################################
$valid_options = &GetOptions( 
  "strFile:s"               => \$str_file, 
  "exportLine:s"            => \$export_line,
  "inputTriangulatedFile:s" => \$input_triangulation, 
  "timingScript:s"          => \$timing_script,
  "parallelism:i"           => \$parallelism
 );

##########################################################################
# Process command line parameters
##########################################################################

if (!defined $str_file)
{
  print "***ERROR:  Must supply a structure file name\n";
  $valid_options = 0;
}
else 
{
  (-e $str_file) or die "***ERROR:  '$str_file' does not exist\n"; 
}

if (!defined $export_line) 
{
  print "***ERROR:  Must supply a pmake export line\n";
  $valid_options = 0;
}

if (!defined $timing_script) 
{ 
  print "***ERROR:  Must supply a script which runs gmtkTime\n";
  $valid_options = 0;
}

if (!$valid_options) 
{
  print "Must give:\n";
  print "  1) Structure file which already has a triangulation\n"; 
  print "  2) An export line specifying a particular speed of processor for inference\n";
  print "  3) Scripts which runs gmtkTime (-inputTriangulatedFile, -strFile, and\n";
  print "     -seconds are passed in as parameters)\n"; 
  print "      -strFile                Structure file name\n";
  print "      -exportLine             pmake export line\n";
  print "      -timingScript           Script running gmtkTime\n";
  print "      -inputTriangulatedFile  Starting triangulation\n";
  die "\n";
}

if (!defined $input_triangulation)
{
  $input_triangulation = "$str_file.trifile";
}
else {
  (-e $input_triangulation) or die "***ERROR:  '$input_triangulation' does not exist\n"; 
}

if (!defined $timing_script) 
{ 
  print "***ERROR:  Must supply a script which runs gmtkTime\n";
  $valid_options = 0;
}

if (!defined $parallelism) 
{
   $parallelism = 1;
}

$str_basename = basename($str_file); 
$working_dir = `pwd`;

chomp($working_dir);

STDOUT->autoflush(1);
$SIG{PIPE} = 'IGNORE';

#############################################################################
# Start a thread for each processor available
#############################################################################
my $last_child;

print "------- Triangulating $str_file -------\n"; 

$start_time = time;

for (my $i=0; $i<$parallelism; $i++) {
  $last_child = threads->new(\&time_triangulation);
  sleep(3);
}

$last_child->join;

die;


#############################################################################
# time_triangulation() 
#
# Thread which fetches a method, runs a triangulation, and times it
#############################################################################
sub time_triangulation 
{
  my $crrnt_partitions;
  my $crrnt_weight;
  my $file_h;
  my $method;
  my $output;
  my $crrnt_pid;
  my $timing_script_input;
  my $timing_script_output;
  my $tmp_name;
  my $tmp_tri_file;

  #####################################################################
  # Open a copy of gmtkTime in multiTest mode 
  #####################################################################
  $timing_script_input  = gensym;
  $timing_script_output = gensym;

  ($crrnt_pid, $timing_script_input, $timing_script_output) = open_time();

  #####################################################################
  # Create a temporary file for the current triangulation 
  #####################################################################
  ($file_h, $tmp_tri_file) = tempfile("$str_basename.tmp.trifile.XXXXX");

  #####################################################################
  # Time the input triangulation 
  #####################################################################
  $initial_sem->up;
  if (!$initial_tri_timed) 
  {
    $initial_tri_timed = 1;
    $initial_sem->down;

    eval {
      $crrnt_partitions = run_timing( $timing_script_input, 
        $timing_script_output, $input_triangulation);
    };
  
    if ($@) { 
      waitpid $crrnt_pid, 0; 
      ($crrnt_pid, $timing_script_input, $timing_script_output) = open_time();
      $crrnt_partitions = -1;
    }

    check_best($crrnt_partitions, 'Initial', 0, $tmp_tri_file);
  }
  else {
    $initial_sem->down;
  }

  #####################################################################
  # Generate and time triangulations 
  #####################################################################
  while (1) {

    $method = get_triangulation_method();
    threads->yield;
    $crrnt_weight = run_triangulation($method, $tmp_tri_file);

    if ($crrnt_weight > 0) {
     
      $crrnt_partitions = -1;
      eval {
        $crrnt_partitions = run_timing( $timing_script_input, 
          $timing_script_output, $tmp_tri_file );
      };
    
      if ($@) {
        waitpid $crrnt_pid, 0; 
        ($crrnt_pid, $timing_script_input, $timing_script_output) = open_time();
      }

      check_best($crrnt_partitions, $method, $crrnt_weight, $tmp_tri_file);
    }
    else {
      print "Triangulation failed\n";
      sleep(15);
    }
  }

  unlink $tmp_tri_file;
}


#############################################################################
# open_time( );
#
#############################################################################
sub open_time
{
  my $error;
  my $output;
  my $pid;
  my $timing_script_input;
  my $timing_script_output;

  do {
    $error = 0;
    eval {
      $pid = open2( $timing_script_output, $timing_script_input, "$export_line $timing_script -strFile $str_file -seconds $timing_length -multiTest T 2>&1 ");

      $timing_script_input->autoflush(1);
      $output = <$timing_script_output>;
      print STDERR "$output";
    };

    if ($@ || ($output=~'no suitable host available')) { 
      $error = 1;
      print "Problem opening timing script:'$output'\n";
      waitpid $pid, 0; 
      sleep(15);
    }
  } while ($error);

  return ($pid, $timing_script_input, $timing_script_output);
}


#############################################################################
# run_triangulation( method );
#
# Triangulates the graph according to the method parameter, uses the local
# processor
#############################################################################
sub run_triangulation
{
  my $method;
  my $output;
  my $jt_weight;
  my $output_tri_file;

  $output_tri_file = pop;
  $method   = pop;

  $output = `$gmtk_triangulate -strFile $str_file -rePartition F -reTriangulate T -findBestBoundary F -inputTriangulatedFile $input_triangulation -findBestBoundary F -seed T -triangulationHeuristic $method -noReTriP T -noReTriC F -noReTriE T -outputTriangulatedFile $output_tri_file -printResults T -numBackupFiles 0 2>&1`;

  print STDERR "$output\n";

  ($jt_weight) = $output =~ /Chunk max clique weight =.* jt_weight = ([0-9.]+)/;

  if (!defined $jt_weight) {
    $jt_weight = -1; 
  }

  return($jt_weight); 
}

#############################################################################
# get_triangulation_method( method );
#
# Get triangulation method from the circular queue  
#############################################################################
sub get_triangulation_method  
{
  my $method;

  $method_sem->up;

  if ($once_index < (scalar @run_once)) {
    $method = $run_once[$once_index];
    $once_index++;
  }
  else {

    $method = "$iterations[$iteration_index]$prefix[$prefix_index]$method[$method_index]";
    if ($method_index >= $suffix_threshold) {
      $method = "$method$suffix[$suffix_index]";
    }

    #########################################################################
    # Increment the method indices
    #########################################################################
    if ($method_index >= $suffix_threshold) {
      $suffix_index++;
      if ($suffix_index >= (scalar @suffix)) {
        $suffix_index = 0;
        $method_index++;
      }
    }

    if ($method_index < $suffix_threshold) {
      $method_index++;
    }

    if ($method_index >= (scalar @method)) {
      $method_index = 0;
      $prefix_index++;
      if ($prefix_index >= (scalar @prefix)) {
        $prefix_index = 0;
        $iteration_index++;
        if ($iteration_index >= (scalar @iterations)) {
          $iteration_index = 0;
        }
      }
    } 
  } 

  #############################################################################
  # Calculate the throughput
  #############################################################################
  $method_count++;
  $method_sem->down;
  if (($method_count % 5)==0) {
    printf "    Throughput:%f\n", (60*$method_count/(time-$start_time));
  } 

  return($method);
}

#############################################################################
# run_timing 
#
#############################################################################
sub run_timing 
{
  my $tri_file;
  my $output;
  my $partitions;

  my $timing_script_input; 
  my $timing_script_output; 

  $tri_file = pop;
  $timing_script_output = pop; 
  $timing_script_input  = pop; 

  print $timing_script_input "$tri_file\n";

  ###########################################################################
  # Read in pre timing output:
  #   exported to ....        # not needed if not exporting  
  #   --------
  #   0: Operating on trifile ''
  #   0: Running program for approximately 7 seconds
  ###########################################################################

  do {
    $output = <$timing_script_output>;
    (defined $output) or die;
    print STDERR "$output";
    chomp($output);
  } while($output ne '--------');

  $output = <$timing_script_output>;
  (defined $output) or die;
  print STDERR "$output";
  $output = <$timing_script_output>;
  (defined $output) or die;
  print STDERR "$output";

  ###########################################################################
  # Read in timing results:
  #   User: 6.980000, System: 0.030000, CPU 7.010000
  #   0: Inference stats: 6.98...
  ###########################################################################
  $output = <$timing_script_output>;
  (defined $output) or die;
  print STDERR "$output";
  $output = <$timing_script_output>;
  (defined $output) or die;
  print STDERR "$output";

  ($partitions) = $output =~ /residual partitions, ([0-9]+) total partitions,/;

  (defined $partitions) or $partitions = -1; 

  return($partitions);
}


#############################################################################
# check_best 
#
#############################################################################
sub check_best 
{
  my $method;
  my $nmbr_partitions;
  my $tmp_tri_file;
  my $weight;

  $tmp_tri_file    = pop;
  $weight          = pop;
  $method          = pop;
  $nmbr_partitions = pop;

  $best_sem->up;

  printf "%-30s Wt: %4f  Part: %5d", $method, $weight, 
    $nmbr_partitions;

  if ($nmbr_partitions > $best_partitions)
  {
    print " ==> NEW BEST!!!\n";
    $best_partitions = $nmbr_partitions;
    copy( $tmp_tri_file, "$str_basename.best.trifile" );
  }
  else 
  {
    print "\n";
  }

  $best_sem->down;
}

#############################################################################
# get_seconds(timestring)
#
# The input is a time string specifying:  seconds, minutes, hours, days, 
#    weeks.  Examples: 
#    '3 seconds 4 minutes 1 hour'  
#    '4min 1 hour 2 days'  
#    '1w3s1h'  
#
# Output is the integer number of seconds represented by the string.
#############################################################################
sub get_seconds 
{
  my $time_string;
  my @strings;
  my $total;
  my $string;
  my $numbers;
  my $letters;
  my $scnds;
  
  $time_string = pop;

  (@strings) = split /(\d+\s*\w+)/, $time_string;

  $total = 0;

  foreach $string (@strings)
  {
    ($numbers, $letters) = $string =~ /(\d+)\s*(\w+)/;

    if ((defined $letters) && (defined $numbers) &&  
        ('seconds' =~ /$letters/)) {
      $total = $total + $numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('minutes' =~ /$letters/)) {
      $total = $total + 60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('hours' =~ /$letters/)) {
      $total = $total + 60*60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('days' =~ /$letters/)) {
      $total = $total + 24*60*60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('weeks' =~ /$letters/)) {
      $total = $total + 7*24*60*60*$numbers;
    }
  }

  return $total;
}


