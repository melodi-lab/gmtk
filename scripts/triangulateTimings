#!/usr/nikola/bin/perl -w 
# $Header$

use strict;
use File::Basename;
use File::Copy;
use File::Temp qw/ tempfile tempdir /;
use Getopt::Long;
use IPC::Open2; 
use Symbol; 
use threads; 
use Thread::Semaphore;

##############################################################################
# Variables for parameters 
##############################################################################
my $valid_options; 
my $str_file; 
my $timing_script;
my $parallelism;
my $export_line;
my $input_triangulation;
my $timing_length; 
my $str_basename;
my $working_dir;

##############################################################################
# Executable names (should eventually be overwritten by command line 
# parameters)
##############################################################################
my $gmtk_triangulate;
my $pmae;
my $pmake;

##############################################################################
# State variables for method queue 
##############################################################################
my $done_initial   : shared = 0;
my $once_method    : shared = 0;
my $many_method    : shared = 0;
my $iteration_type : shared = 0;
my $method_sem = new Thread::Semaphore;

my @run_once = ( 'completed', 'elimination-heuristics', 
  'non-elimination-heuristics' );
my @run_many = ( 'R', 'W', 'MCS', 'F', 'pre-edge-lo-R', 'pre-edge-lo-W', 'pre-edge-lo-MCS', 'pre-edge-lo-F', 'pre-edge-all-R', 'pre-edge-all-W', 'pre-edge-all-MCS', 'pre-edge-all-F', 'pre-edge-random-R', 'pre-edge-random-W', 'pre-edge-random-MCS', 'pre-edge-random-F' );
my @iterations = ( 100, 10, 1 ); 

my $initial_sem = new Thread::Semaphore;
my $initial_tri_timed : shared = 0;

##############################################################################
# State variables for comparing triangulation methods 
##############################################################################
my $best_partitions : shared = 0; 
my $best_sem = new Thread::Semaphore;

##############################################################################
# GMTK tool names
# -Do not add paths to these definitons, alter your path instead
##############################################################################
$gmtk_triangulate = 'gmtkTriangulate'; 
$pmae             = 'pmae'; 
$pmake            = 'pmake'; 

$timing_length = 7; 
#$timing_length = 20; 

##############################################################################
# Get command line parameters 
##############################################################################
$valid_options = &GetOptions( 
  "strFile:s"               => \$str_file, 
  "exportLine:s"            => \$export_line,
  "inputTriangulatedFile:s" => \$input_triangulation, 
  "timingScript:s"          => \$timing_script,
  "parallelism:i"           => \$parallelism
 );

##########################################################################
# Process command line parameters
##########################################################################

if (!defined $str_file)
{
  print "***ERROR:  Must supply a structure file name\n";
  $valid_options = 0;
}
else 
{
  (-e $str_file) or die "***ERROR:  '$str_file' does not exist\n"; 
}

if (!defined $export_line) 
{
  print "***ERROR:  Must supply a pmake export line\n";
  $valid_options = 0;
}

if (!defined $timing_script) 
{ 
  print "***ERROR:  Must supply a script which runs gmtkTime\n";
  $valid_options = 0;
}

if (!$valid_options) 
{
  print "Must give:\n";
  print "  1) Structure file which already has a triangulation\n"; 
  print "  2) An export line specifying a particular speed of processor for inference\n";
  print "  3) Scripts which runs gmtkTime (-inputTriangulatedFile, -strFile, and\n";
  print "     -seconds are passed in as parameters)\n"; 
  print "      -strFile                Structure file name\n";
  print "      -exportLine             pmake export line\n";
  print "      -timingScript           Script running gmtkTime\n";
  print "      -inputTriangulatedFile  Starting triangulation\n";
  die "\n";
}

if (!defined $input_triangulation)
{
  $input_triangulation = "$str_file.trifile";
}
else {
  (-e $input_triangulation) or die "***ERROR:  '$input_triangulation' does not exist\n"; 
}

if (!defined $timing_script) 
{ 
  print "***ERROR:  Must supply a script which runs gmtkTime\n";
  $valid_options = 0;
}

if (!defined $parallelism) 
{
   $parallelism = 1;
}

$str_basename = basename($str_file); 
$working_dir = `pwd`;
#$working_dir = '/homes/bartels/proj/crrnt_gmtk/gmtk_dev/scripts';
#$working_dir = '/homes/bartels/proj/switchboard/train_1';

chomp($working_dir);


#############################################################################
# Start a thread for each processor available
#############################################################################
my $last_child;

for (my $i=0; $i<$parallelism; $i++) {
  $last_child = threads->new(\&time_triangulation);
}

$last_child->join;

die;


#############################################################################
# time_triangulation() 
#
# Thread which fetches a method, runs a triangulation, and times it
#############################################################################
sub time_triangulation 
{
  my $crrnt_partitions;
  my $crrnt_weight;
  my $file_h;
  my $method;
  my $output;
  my $timing_script_input;
  my $timing_script_output;
  my $tmp_name;
  my $tmp_tri_file;

  #####################################################################
  # Open a copy of gmtkTime in multiTest mode 
  #####################################################################
  $timing_script_input  = gensym;
  $timing_script_output = gensym;
  
  open2( $timing_script_output, $timing_script_input, "pexport -attr \'$export_line\' $timing_script -strFile $str_file -seconds $timing_length -multiTest T 2>&1 ");

  $output = <$timing_script_output>;
  print STDERR "$output";

  #####################################################################
  # Create a temporary file for the current triangulation 
  #####################################################################
  ($file_h, $tmp_tri_file) = tempfile("$str_basename.tmp.trifile.XXXXX");

  #####################################################################
  # Time the input triangulation 
  #####################################################################
  $initial_sem->up;
  if (!$initial_tri_timed) 
  {
    $initial_tri_timed = 1;
    $initial_sem->down;
    $crrnt_partitions = run_timing( $timing_script_input, $timing_script_output,
       $input_triangulation);

    check_best($crrnt_partitions, 'Initial', $crrnt_weight, $tmp_tri_file);
  }
  else {
    $initial_sem->down;
  }

  #####################################################################
  # Generate and time triangulations 
  #####################################################################
  while (1) {
    $method = get_triangulation_method();  
    $crrnt_weight = run_triangulation($method, $tmp_tri_file);
    $crrnt_partitions = run_timing( $timing_script_input, $timing_script_output,
       $tmp_tri_file );

    check_best($crrnt_partitions, $method, $crrnt_weight, $tmp_tri_file);
  }

  unlink $tmp_tri_file;
}



#############################################################################
# run_triangulation( method );
#
# Triangulates the graph according to the method parameter, uses the local
# processor
#############################################################################
sub run_triangulation
{
  my $method;
  my $output;
  my $jt_weight;
  my $output_tri_file;

  $output_tri_file = pop;
  $method   = pop;

  $output = `$gmtk_triangulate -strFile $str_file -rePartition F -reTriangulate T -findBestBoundary F -inputTriangulatedFile $input_triangulation -findBestBoundary F -seed T -triangulationHeuristic $method -noReTriP T -noReTriC F -noReTriE T -outputTriangulatedFile $output_tri_file -printResults T -numBackupFiles 0 2>&1`;

  print STDERR "${output}";
  ($jt_weight) = $output =~ /Chunk max clique weight =.* jt_weight = ([0-9.]+)/; 

  if (!defined $jt_weight) {
    $jt_weight = -1; 
  }

  return($jt_weight); 
}

#############################################################################
# get_triangulation_method( method );
#
# Get triangulation method from the circular queue  
#############################################################################
sub get_triangulation_method  
{
  my $method;

  $method_sem->up;

  if ($once_method < (scalar @run_once)) {
    $method = $run_once[$once_method];
    $once_method++;
  }
  else {
    $many_method++;

    if ($many_method >= (scalar @run_many)) {
      $many_method = 0;
      $iteration_type++;

      if ($iteration_type>= (scalar @iterations)) {
        $iteration_type = 0;
      }
    }

    $method = "$iterations[$iteration_type]-$run_many[$many_method]";
  }

  $method_sem->down;
  return($method);
}


#############################################################################
# run_timing 
#
#############################################################################
sub run_timing 
{
  my $tri_file;
  my $output;
  my $partitions;

  my $timing_script_input; 
  my $timing_script_output; 

  $tri_file = pop;
  $timing_script_output = pop; 
  $timing_script_input  = pop; 

  print $timing_script_input "$tri_file\n";

  ###########################################################################
  # Read in pre timing output:
  #   exported to ....        # not needed if not exporting  
  #   --------
  #   0: Operating on trifile ''
  #   0: Running program for approximately 7 seconds
  ###########################################################################
  $output = <$timing_script_output>;
  print STDERR "$output";
  $output = <$timing_script_output>;
  print STDERR "$output";
  $output = <$timing_script_output>;
  print STDERR "$output";

  ###########################################################################
  # Read in timing results:
  #   User: 6.980000, System: 0.030000, CPU 7.010000
  #   0: Inference stats: 6.98...
  ###########################################################################
  $output = <$timing_script_output>;
  print STDERR "$output";
  $output = <$timing_script_output>;
  print STDERR "$output";

  ($partitions) = $output =~ /residual partitions, ([0-9]+) total partitions,/;

  (defined $partitions) or die "Can't find # of partitions in output:'$output'";

  return($partitions);
}


#############################################################################
# check_best 
#
#############################################################################
sub check_best 
{
  my $method;
  my $nmbr_partitions;
  my $tmp_tri_file;
  my $weight;

  $tmp_tri_file    = pop;
  $weight          = pop;
  $method          = pop;
  $nmbr_partitions = pop;

  $best_sem->up;

  printf "%-30s Weight: %4f  Partitions: %5d", $method, $weight, 
    $nmbr_partitions;

  if ($nmbr_partitions > $best_partitions)
  {
    print " ==> NEW BEST!!!\n";
    $best_partitions = $nmbr_partitions;
    copy( $tmp_tri_file, "$str_basename.best.trifile" );
  }
  else 
  {
    print "\n";
  }

  $best_sem->down;
}

#############################################################################
# get_seconds(timestring)
#
# The input is a time string specifying:  seconds, minutes, hours, days, 
#    weeks.  Examples: 
#    '3 seconds 4 minutes 1 hour'  
#    '4min 1 hour 2 days'  
#    '1w3s1h'  
#
# Output is the integer number of seconds represented by the string.
#############################################################################
sub get_seconds 
{
  my $time_string;
  my @strings;
  my $total;
  my $string;
  my $numbers;
  my $letters;
  my $scnds;
  
  $time_string = pop;

  (@strings) = split /(\d+\s*\w+)/, $time_string;

  $total = 0;

  foreach $string (@strings)
  {
    ($numbers, $letters) = $string =~ /(\d+)\s*(\w+)/;

    if ((defined $letters) && (defined $numbers) &&  
        ('seconds' =~ /$letters/)) {
      $total = $total + $numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('minutes' =~ /$letters/)) {
      $total = $total + 60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('hours' =~ /$letters/)) {
      $total = $total + 60*60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('days' =~ /$letters/)) {
      $total = $total + 24*60*60*$numbers;
    }
    elsif ((defined $letters) && (defined $numbers) &&  
           ('weeks' =~ /$letters/)) {
      $total = $total + 7*24*60*60*$numbers;
    }
  }

  return $total;
}


